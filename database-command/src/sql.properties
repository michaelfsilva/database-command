# FILE WITH EVERY SQL USED IN THE LABEL COMMAND APPLICATION

################################## CREATE TEMP TABLE WITH LABEL DATA ########################################
# create a connection on destination db and get label data from label, label component and label part tables
# NOTE: replace '_server' and '_dbname' to entry variables
GET_LBL_DATA = do $$ declare tConnName text := 'dbcmd'; tConnInfo text := 'host=_server dbname=_dbname use=postgres password=postgres'; begin DROP TABLE IF EXISTS tt_label; DROP TABLE IF EXISTS tt_lc; DROP TABLE IF EXISTS tt_lp; if dblink_get_connections() @> array[tConnName] then PERFORM dblink_disconnect(tConnName); end if; begin PERFORM dblink_connect_u(tConnName, tConnInfo); exception when others then raise exception 'Exception occurred during the connection.'; end; begin CREATE TEMP TABLE tt_label AS SELECT * FROM dblink(tConnName, 'SELECT released_label, modification_ts, label_type, alt_init_string, procedure_name, part_key, format_name, print_quantity, template_key, use_template, template_flag, a1, i1, l1, output_destination, is_generic FROM label') AS t(released_label boolean, modification_ts timestamp with time zone, label_type integer, alt_init_string text, procedure_name text, part_key integer, format_name text, print_quantity integer, template_key integer, use_template boolean, template_flag boolean, a1 text, i1 integer, l1 boolean, output_destination text, is_generic boolean); CREATE TEMP TABLE tt_lc AS SELECT * FROM dblink(tConnName, 'SELECT printer_type, print_cmd_title, print_cmd_string, print_cmd_type, print_row_position, print_column_position, font_cmd_string, rotation, label_type, data_id, download_graphic, mandatory_flag, mandatory_fail_msg, a1, i1, l1 FROM label_component') AS t(printer_type text, print_cmd_title text, print_cmd_string text, print_cmd_type integer, print_row_position integer, print_column_position integer, font_cmd_string text, rotation text, label_type integer, data_id text, download_graphic boolean, mandatory_flag boolean, mandatory_fail_msg text, a1 text, i1 integer, l1 boolean); CREATE TEMP TABLE tt_lp AS SELECT * FROM dblink(tConnName, 'SELECT label_type, i1, label_text1, label_text2, label_text3, label_text4, label_text5 FROM label_part') AS t(label_type int, i1 int, label_text1 text, label_text2 text, label_text3 text, label_text4 text, label_text5 text); PERFORM dblink_disconnect(tConnName); exception when others then if dblink_get_connections() @> array[tConnName] then PERFORM dblink_disconnect(tConnName); end if; end; end; $$

#do $$
#declare
#    tConnName text := 'dbcmd';
#    tConnInfo text := 'host=p88mdb1 dbname=dev1 use=postgres password=postgres';
#
#begin
#    DROP TABLE IF EXISTS tt_label;
#    DROP TABLE IF EXISTS tt_lc;
#    DROP TABLE IF EXISTS tt_lp;
#
#    --if the connection already exists, disconnect
#    if dblink_get_connections() @> array[tConnName] then
#	PERFORM dblink_disconnect(tConnName);
#    end if;
#
#    --create a connection
#    begin
#    	PERFORM dblink_connect_u(tConnName, tConnInfo);
#    exception
#	when others then
#	    raise exception 'Exception occurred during the connection.';
#    end;
#
#    begin
#	CREATE TEMP TABLE tt_label AS
#	    SELECT * FROM dblink(tConnName, 'SELECT released_label, modification_ts, label_type, alt_init_string,
#												procedure_name, part_key, format_name, print_quantity, template_key,
#												use_template, template_flag, a1, i1, l1, output_destination,
#	    										is_generic FROM label')
#		AS t(released_label boolean, modification_ts timestamp with time zone,
#		     label_type integer, alt_init_string text, procedure_name text, part_key integer, format_name text,
#		     print_quantity integer, template_key integer, use_template boolean, template_flag boolean, a1 text,
#		     i1 integer, l1 boolean, output_destination text, is_generic boolean);
#
#	CREATE TEMP TABLE tt_lc AS
#	    SELECT * FROM dblink(tConnName, 'SELECT printer_type, print_cmd_title, print_cmd_string, print_cmd_type,
#						    print_row_position, print_column_position, font_cmd_string, rotation, label_type,
#						    data_id, download_graphic, mandatory_flag, mandatory_fail_msg, a1, i1, l1
#					     FROM label_component')
#		AS t(printer_type text, print_cmd_title text, print_cmd_string text, print_cmd_type integer,
#		     print_row_position integer, print_column_position integer, font_cmd_string text, rotation text, label_type integer,
#		     data_id text, download_graphic boolean, mandatory_flag boolean, mandatory_fail_msg text, a1 text, i1 integer, l1 boolean);
#
#	CREATE TEMP TABLE tt_lp AS
#	    SELECT * FROM dblink(tConnName, 'SELECT label_type, i1, label_text1, label_text2,
#						    label_text3, label_text4, label_text5 FROM label_part')
#		AS t(label_type int, i1 int, label_text1 text, label_text2 text, label_text3 text, label_text4 text, label_text5 text);
#
#	--if everything was ok, disconnect
#    	PERFORM dblink_disconnect(tConnName);
#    exception
#    	when others then
#	    if dblink_get_connections() @> array[tConnName] then
#	    	PERFORM dblink_disconnect(tConnName);
#	    end if;
#    end;
#end; $$

################################# COMPARE LABEL TABLE DATA ########################################
# compare informations from label table between both databases and return the exceptions 
COMPARE_LABEL = SELECT released_label, modification_ts, label_type, alt_init_string, procedure_name, part_key, format_name, print_quantity, template_key, use_template, template_flag, a1, i1, l1, output_destination, is_generic FROM label EXCEPT SELECT * FROM tt_label ORDER BY label_type

############################# COMPARE LABEL COMPONENT TABLE DATA ##################################
# compare informations from label_component table between both databases and return the exceptions 
COMPARE_LBLCOMP = SELECT printer_type, print_cmd_title, print_cmd_string, print_cmd_type, print_row_position, print_column_position, font_cmd_string, rotation, label_type, data_id, download_graphic, mandatory_flag, mandatory_fail_msg, a1, i1, l1 FROM label_component EXCEPT SELECT * FROM tt_lc ORDER BY label_type

################################ COMPARE LABEL PART TABLE DATA ####################################
# compare informations from label_component table between both databases and return the exceptions 
COMPARE_LBLPART = SELECT label_type, i1, label_text1, label_text2, label_text3, label_text4, label_text5 FROM label_part EXCEPT SELECT * FROM tt_lp ORDER BY label_type

####################################### COMPARE FUNCTIONS #############################################
# compare informations from label table to functions installed on database
COMPARE_FUNC = SELECT DISTINCT l.label_type, l.procedure_name FROM label l LEFT JOIN pg_proc p ON l.procedure_name = p.proname WHERE l.procedure_name LIKE 'lbl_%' AND p.proname is null AND substring(reverse(l.label_type::text), 3, 1) <> '2' ORDER BY l.label_type

# compare informations from label table to functions installed on database and svn path passed
# note: replace the variables _svnpath, _user and _pass to entry variables
COMPARE_FUNC_SVN = SELECT DISTINCT l.label_type, l.procedure_name, coalesce(replace(svn,svn,'yes'), 'no') as svn FROM label l LEFT JOIN pg_proc p ON l.procedure_name = p.proname LEFT JOIN regexp_split_to_table(csyscall('svn ls _svnpath --username _user --password "_pass" --no-auth-cache'),E'\n') as svn on l.procedure_name = replace(svn, '.sql', '') WHERE l.procedure_name LIKE 'lbl_%' AND p.proname is null AND substring(reverse(l.label_type::text), 3, 1) <> '2' ORDER BY l.label_type

# compare label functions to svn branch and trunk passed
# note: replace the variables _branchpath, _trunkpath, _user and _pass to entry variables
COMPARE_SVN_PATH = do $$ declare tProcName text; tBranch text; tTrunk text; begin DROP TABLE IF EXISTS tt_checkfunction; DROP TABLE IF EXISTS tt_svn_branch; DROP TABLE IF EXISTS tt_svn_trunk; CREATE TEMP TABLE tt_checkfunction(function_name text, branch_size text, trunk_size text); CREATE TEMP TABLE tt_svn_branch(file_desc text) ON COMMIT DROP; CREATE TEMP TABLE tt_svn_trunk(file_desc text) ON COMMIT DROP; INSERT INTO tt_svn_branch SELECT regexp_split_to_table(csyscall('svn list _branchpath -v --username _user --password "_pass" --no-auth-cache'), chr(10)); INSERT INTO tt_svn_trunk SELECT regexp_split_to_table(csyscall('svn list _trunkpath -v --username _user --password "_pass" --no-auth-cache'), chr(10)); if exists(SELECT true FROM tt_svn_branch WHERE lower(file_desc) like '%non-existent in that revision%') or exists(SELECT true FROM tt_svn_trunk WHERE lower(file_desc) like '%non-existent in that revision%') then INSERT INTO tt_checkfunction VALUES('SVN path(s) not found.'); return; end if; if exists(SELECT true FROM tt_svn_branch WHERE lower(file_desc) like '%authentication realm%') then INSERT INTO tt_checkfunction VALUES('Invalid username or password.'); return; end if; for tProcName in SELECT procedure_name FROM label WHERE procedure_name LIKE 'lbl%' AND substring(reverse(label_type::text),3,1) <> '2' GROUP BY procedure_name ORDER BY procedure_name loop SELECT split_part(trim(split_part(file_desc,'     ',2)),' ',1) FROM tt_svn_branch WHERE file_desc like '%' || tProcName || '.sql' INTO tBranch; SELECT split_part(trim(split_part(file_desc,'     ',2)),' ',1) FROM tt_svn_trunk WHERE file_desc like '%' || tProcName || '.sql' INTO tTrunk; tBranch := coalesce(tBranch,'NOT FOUND'); tTrunk  := coalesce(tTrunk,'NOT FOUND'); if (tBranch <> tTrunk) OR (tBranch = 'NOT FOUND' AND tTrunk = 'NOT FOUND') then INSERT INTO tt_checkfunction VALUES(tProcName, tBranch, tTrunk); else INSERT INTO tt_checkfunction VALUES(tProcName, 'Same file size.', ''); end if; end loop; end; $$

#do $$
#declare
#    tProcName text;
#    tBranch text;
#    tTrunk text;
#
#begin
#    DROP TABLE IF EXISTS tt_checkfunction;
#    DROP TABLE IF EXISTS tt_svn_branch;
#    DROP TABLE IF EXISTS tt_svn_trunk;
#    CREATE TEMP TABLE tt_checkfunction(function_name text, branch_size text, trunk_size text);
#    CREATE TEMP TABLE tt_svn_branch(file_desc text) ON COMMIT DROP;
#    CREATE TEMP TABLE tt_svn_trunk(file_desc text) ON COMMIT DROP;
#
#	--inserting paths file list into temp tables 
#    INSERT INTO tt_svn_branch SELECT regexp_split_to_table(csyscall('svn list _branchpath -v --username _user --password "_pass" --no-auth-cache'), chr(10));
#    INSERT INTO tt_svn_trunk SELECT regexp_split_to_table(csyscall('svn list _trunkpath -v --username _user --password "_pass" --no-auth-cache'), chr(10));
#
#	--checking if the paths exists
#    if exists(SELECT true FROM tt_svn_branch WHERE lower(file_desc) like '%non-existent in that revision%')
#		or exists(SELECT true FROM tt_svn_trunk WHERE lower(file_desc) like '%non-existent in that revision%') then
#
#		INSERT INTO tt_checkfunction VALUES('SVN path(s) not found.');
#		return;
#    end if;
#
#	--checking if authentication is ok
#    if exists(SELECT true FROM tt_svn_branch WHERE lower(file_desc) like '%authentication realm%') then
#		INSERT INTO tt_checkfunction VALUES('Invalid username or password.');
#		return;
#    end if;
#
#    for tProcName in SELECT procedure_name FROM label WHERE procedure_name LIKE 'lbl%'
#			AND substring(reverse(label_type::text),3,1) <> '2' GROUP BY procedure_name ORDER BY procedure_name
#    loop
#		--get the files size
#		SELECT split_part(trim(split_part(file_desc,'     ',2)),' ',1) FROM tt_svn_branch WHERE file_desc like '%' || tProcName || '.sql' INTO tBranch;
#		SELECT split_part(trim(split_part(file_desc,'     ',2)),' ',1) FROM tt_svn_trunk WHERE file_desc like '%' || tProcName || '.sql' INTO tTrunk;
#
#		-- if null file was not found
#		tBranch := coalesce(tBranch,'NOT FOUND');
#		tTrunk  := coalesce(tTrunk,'NOT FOUND');
#
#		--checking if files exists or are the same
#		if (tBranch <> tTrunk) OR (tBranch = 'NOT FOUND' AND tTrunk = 'NOT FOUND') then
#			INSERT INTO tt_checkfunction VALUES(tProcName, tBranch, tTrunk);
#		else
#			INSERT INTO tt_checkfunction VALUES(tProcName, 'Same file size.', '');
#		end if;
#    end loop;
#end;

# get data generated from CHECK_SVN_PATH
GET_SVN_PATH = SELECT DISTINCT function_name, branch_size, trunk_size FROM tt_checkfunction ORDER BY function_name

####################################### CHECK ENVIROMENT ##############################################
# check environment folders on server
#CHECK_ENV_OLD = SELECT csyscall AS directory FROM csyscall('cat /Bkup/bkup_labels') UNION SELECT csyscall AS directory FROM csyscall('cat /Bkup/deleted_labels') UNION SELECT csyscall AS directory FROM csyscall('cat /graphics/' || (SELECT dataset_name FROM dataset)) UNION SELECT csyscall AS directory FROM csyscall('cat /graphics/FONT')
CHECK_ENV = SELECT csyscall AS directory FROM csyscall('cat /Bkup/bkup_labels') UNION SELECT csyscall AS directory FROM csyscall('cat /Bkup/deleted_labels') UNION SELECT csyscall AS directory FROM csyscall('cat /graphics/' || (SELECT dataset_name FROM dataset WHERE dataset_key = 0 LIMIT 1)) UNION SELECT csyscall AS directory FROM csyscall('cat /graphics/FONT')

##################################### COMPARE FORMAT FILES ############################################
# compare informations from label table to files on server project folder 
CHECK_FORMAT = SELECT label_type, substring(split_part(split_part(alt_init_string, '.', 1), ';', 1), 2) AS format FROM label WHERE alt_init_string LIKE 'F%'  AND substring(reverse(label_type::text), 3, 1) <> '2' AND substring(split_part(split_part(alt_init_string, '.', 1), ';', 1), 2) NOT IN (SELECT split_part(regexp_split_to_table(csyscall('ls /graphics/' || dataset_name || '/'), E'\n'), '.', 1) FROM dataset) GROUP BY label_type, format ORDER BY label_type

###################################### COMPARE FONT FILES #############################################
# compare fonts from label_part table to fonts on server project folder 
CHECK_FONTS = SELECT label_type, split_part(label_text3, '.', 1) AS font FROM label_part WHERE label_text1 = 'font' AND substring(reverse(label_type::text), 3, 1) <> '2' AND split_part(label_text3, '.', 1) NOT IN (SELECT split_part(regexp_split_to_table(csyscall('ls /graphics/FONT/'), E'\n'), '.', 1)) GROUP BY label_type, font ORDER BY label_type

##################################### COMPARE GRAPHIC FILES ###########################################
# compare fonts from label_component table to graphics on server project folder 
CHECK_GRAPH = SELECT label_type, split_part(split_part(print_cmd_string, ',', 2), '^XG', 2) AS graphic FROM label_component WHERE print_cmd_type = 5 AND print_cmd_string LIKE '"^%' AND substring(reverse(label_type::text), 3, 1) <> '2' AND print_cmd_string NOT LIKE '%proc_data%' AND split_part(split_part(print_cmd_string, ',', 2), '^XG', 2) NOT IN ( SELECT split_part(regexp_split_to_table(csyscall('ls /graphics/' || dataset_name || '/'), E'\n'), '.', 1) FROM dataset) UNION SELECT label_type, split_part(print_cmd_string, '.', 1) AS graphic FROM label_component WHERE print_cmd_type = 3 AND print_cmd_string <> '' AND substring(reverse(label_type::text), 3, 1) <> '2' AND print_cmd_string NOT LIKE '%proc_data%' AND print_cmd_string NOT LIKE '^GB%' AND split_part(print_cmd_string, '.', 1) NOT IN ( SELECT split_part(regexp_split_to_table(csyscall('ls /graphics/' || dataset_name || '/'), E'\n'), '.', 1) FROM dataset) GROUP BY label_type, graphic ORDER BY label_type

####################### CREATE TEMP TABLE WITH LABEL COMPONENT TABLE ISSUES ###########################
# create a connection on destination db and get label component issues 
GET_COMP_ISSUES = do $$ declare rLC record; query_statement text := 'SELECT _field FROM _table LIMIT 1'; tCmd   text; tTable text; tField text; begin DROP TABLE IF EXISTS tt_lblcomp; CREATE TEMP TABLE tt_lblcomp(issues text); for rLC in SELECT label_type, label_component_key, print_cmd_title, print_cmd_string FROM label_component WHERE print_cmd_string LIKE '%db:%' AND substring(reverse(label_type::text), 3, 1) <> '2' ORDER BY label_type loop for tCmd in SELECT split_part(split_part(regexp_split_to_table, '+', 1), '(', 1) FROM regexp_split_to_table(rLC.print_cmd_string, 'db:') WHERE coalesce(regexp_split_to_table, '') <> '' loop tTable := split_part(tCmd, '.', 1); tField := split_part(tCmd, '.', 2); end loop; query_statement := replace(query_statement, '_field', tField); query_statement := replace(query_statement, '_table', tTable); begin EXECUTE query_statement; exception when others then INSERT INTO tt_lblcomp SELECT concat(rLC.label_type, E'\t', rpad(rLC.label_component_key::text,13,' '), rpad(rLC.print_cmd_title,31,' '), rLC.print_cmd_string); end; query_statement := 'SELECT _field FROM _table LIMIT 1'; end loop; end; $$

#do $$
#declare
#    rLC record;
#    query_statement text := 'SELECT _field FROM _table LIMIT 1';
#    tCmd   text;
#    tTable text;
#    tField text;
#
#begin
#    DROP TABLE IF EXISTS tt_lblcomp;
#    CREATE TEMP TABLE tt_lblcomp(issues text);
#
#    for rLC in SELECT label_type, label_component_key, print_cmd_title, print_cmd_string FROM label_component WHERE print_cmd_string LIKE '%db:%' AND substring(reverse(label_type::text), 3, 1) <> '2' ORDER BY label_type loop
#	for tCmd in SELECT split_part(split_part(regexp_split_to_table, '+', 1), '(', 1)
#		    FROM regexp_split_to_table(rLC.print_cmd_string, 'db:')
#		    WHERE coalesce(regexp_split_to_table, '') <> '' loop
#	    tTable := split_part(tCmd, '.', 1);
#	    tField := split_part(tCmd, '.', 2);
#	end loop;
#
#	query_statement := replace(query_statement, '_field', tField);
#	query_statement := replace(query_statement, '_table', tTable);
#    
#	begin
#	    EXECUTE query_statement;
#	    
#	exception
#	    when others then
#		INSERT INTO tt_lblcomp SELECT concat(rLC.label_type, E'\t', rpad(rLC.label_component_key::text,13,' '), rpad(rLC.print_cmd_title,31,' '), rLC.print_cmd_string);
#	end;
#
#	query_statement := 'SELECT _field FROM _table LIMIT 1';
#    end loop;
#end; $$

################################### CHECK COMPONENT ISSUES #######################################
# check if exists any label component with issues 
CHECK_COMP = SELECT issues FROM tt_lblcomp

################################## GET LABELS WITH _WORD  ######################################
# get label components that have the word passed as parameter
# note: replace the variable _word to entry variable
GET_WORD = SELECT label_type, print_cmd_title, print_cmd_string FROM label_component WHERE lower(print_cmd_string) LIKE lower('%_word%') AND substring(reverse(label_type::text), 3, 1) <> '2' ORDER BY label_type

########################### GET LABELS WITH _WORD FROM LABEL ENGINE ##################################
# get label key and name that have the word passed as parameter
# note: replace the variable _word to entry variable
GET_WORD_LE = do $$ declare tConnName text := 'lblcmd_wordsearch_labelengine'; tDbName text; rGattr record; begin DROP TABLE IF EXISTS tt_label; CREATE TEMP TABLE tt_label(label_key text, label_name text, element_name text); if dblink_get_connections() @> array[tConnName] then PERFORM dblink_disconnect(tConnName); end if; begin PERFORM dblink_connect_u(tConnName, 'dbname='|| '_dbName' ||' user=postgres password=postgres'); exception when others then raise exception 'Exception occurred during the connection.'; end; begin INSERT INTO tt_label SELECT * FROM dblink(tConnName, 'SELECT lbl.label_key::text, lbl.name, lbl_view.element_name FROM label lbl  INNER JOIN label_element_and_block_details_view lbl_view  ON lbl.label_key = lbl_view.label_key  AND block_type_description = ''DB Table.Column Value''  AND (output_db_column_name like lower(''_word'') OR output_db_table_name like lower(''_word''))') AS t(label_key text, label_name text, element_name text); PERFORM dblink_disconnect(tConnName); exception when others then if dblink_get_connections() @> array[tConnName] then PERFORM dblink_disconnect(tConnName); end if; end; end; $$

#do $$
#declare
#    tConnName text := 'lblcmd_wordsearch_labelengine';
#    tDbName text;
#    rGattr record;
#
#begin
#    DROP TABLE IF EXISTS tt_label;
#    CREATE TEMP TABLE tt_label(label_key text, label_name text, element_name text);
#
#    --if the connection already exists, disconnect
#    -- dblink_get_connections() -- returns the names of all open named dblink connections
#    if dblink_get_connections() @> array[tConnName] then
#	PERFORM dblink_disconnect(tConnName);
#    end if;
#	
#	--create a connection
#	begin
#	    PERFORM dblink_connect_u(tConnName, 'dbname='|| '_dbName' ||' user=postgres password=postgres');
#	    --select dblink_connect_u('tConnName', 'dbname='|| 'dev1' ||' user=postgres password=postgres');
#	exception
#	    when others then
#		raise exception 'Exception occurred during the connection.';
#	end;
#
#	begin
#	    --get data through the connection
#	    INSERT INTO tt_label
#		SELECT * FROM dblink(tConnName,
#			'SELECT lbl.label_key::text, lbl.name, lbl_view.element_name FROM label lbl 
#			INNER JOIN label_element_and_block_details_view lbl_view 
#			ON lbl.label_key = lbl_view.label_key 
#			AND block_type_description = ''DB Table.Column Value'' 
#			AND (output_db_column_name like lower(''_word'') OR output_db_table_name like lower(''_word''))')
#		AS t(label_key text, label_name text, element_name text);
#
#	    --if everything was ok, disconnect
#	    PERFORM dblink_disconnect(tConnName);
#
#	exception
#	    when others then
#		if dblink_get_connections() @> array[tConnName] then
#		    PERFORM dblink_disconnect(tConnName);
#		end if;
#	end;
#end; $$

################################### CHECK LABELS WITH WORD FROM LE #######################################
# check if exists any label component with _word used 
CHECK_WORD_LE = SELECT label_key, label_name, element_name FROM tt_label

####################################### GETLABELS QUANTITY ##########################################
# getlabels print quantity summarized in a specific period
GET_SUM_QTY = SELECT concat(database,' | ',sum(quantity::int)) as sum_qty FROM (SELECT replace(replace(split_part(regexp_split_to_table, ' ', 1), '[', ''), ']', '') date, replace(replace(split_part(regexp_split_to_table, ' ', 2), '[', ''), ']', '') as database, split_part(split_part(regexp_split_to_table, 'LT:', 2), '-', 2) quantity FROM regexp_split_to_table(csyscall('cat /logs/labels_print_qty.log'), E'\n')) as t WHERE coalesce(quantity, '') <> '' AND date BETWEEN '_inidate' AND '_enddate' GROUP BY database ORDER BY database

#SELECT concat(database,' | ',sum(quantity::int)) FROM (
# SELECT replace(replace(split_part(regexp_split_to_table, ' ', 1), '[', ''), ']', '') date,
#       replace(replace(split_part(regexp_split_to_table, ' ', 2), '[', ''), ']', '') as database,
#       split_part(split_part(regexp_split_to_table, 'LT:', 2), '-', 2) quantity
# FROM regexp_split_to_table(csyscall('cat /logs/labels_print_qty.log'), E'\n')
#) as t
#WHERE coalesce(quantity, '') <> '' AND date BETWEEN '_inidate' AND '_enddate'
#GROUP BY database ORDER BY database

# getlabels print quantity detailed in a specific period
GET_DTL_QTY = SELECT database, label_type, sum(quantity::int) quantity FROM (SELECT replace(replace(split_part(regexp_split_to_table, ' ', 1), '[', ''), ']', '') date, replace(replace(split_part(regexp_split_to_table, ' ', 2), '[', ''), ']', '') as database, split_part(split_part(regexp_split_to_table, 'LT:', 2), '-', 1) label_type, split_part(split_part(regexp_split_to_table, 'LT:', 2), '-', 2) quantity FROM regexp_split_to_table(csyscall('cat /logs/labels_print_qty.log'), E'\n')) as t WHERE coalesce(quantity, '') <> '' AND date BETWEEN '_inidate' AND '_enddate' AND database = '_dbname' GROUP BY database, label_type ORDER BY database, label_type::int

#SELECT database, label_type, sum(quantity::int) quantity FROM (
# SELECT replace(replace(split_part(regexp_split_to_table, ' ', 1), '[', ''), ']', '') date,
#       replace(replace(split_part(regexp_split_to_table, ' ', 2), '[', ''), ']', '') as database,
#       split_part(split_part(regexp_split_to_table, 'LT:', 2), '-', 1) label_type,
#       split_part(split_part(regexp_split_to_table, 'LT:', 2), '-', 2) quantity
# FROM regexp_split_to_table(csyscall('cat /logs/labels_print_qty.log'), E'\n')
#) as t
#WHERE coalesce(quantity, '') <> '' AND date BETWEEN '_inidate' AND '_enddate' AND database = '_dbname'
#GROUP BY database, label_type
#ORDER BY database, label_type::int

#do $$
#declare
#    rLoop record;
#    tDb   text := '';
#
#begin
#    CREATE TEMP TABLE tt_printqty(quantity text);
#
#    for rLoop in  SELECT * FROM (SELECT replace(replace(split_part(regexp_split_to_table, ' ', 1), '[', ''), ']', '') date,
#			 replace(replace(split_part(regexp_split_to_table, ' ', 2), '[', ''), ']', '') as database,
#			 split_part(split_part(regexp_split_to_table, 'LT:', 2), '-', 1) label_type,
#			 split_part(split_part(regexp_split_to_table, 'LT:', 2), '-', 2) quantity
#		  FROM regexp_split_to_table(csyscall('cat /logs/labels_print_qty.log'), E'\n')) as t WHERE coalesce(quantity, '') <> ''
#		  ORDER BY database, label_type::int
#    loop
#	if rLoop.database <> tDb then
#	    INSERT INTO tt_printqty VALUES('');
#	    INSERT INTO tt_printqty VALUES(concat('Database: ',rLoop.database));
#	end if;
#
#	INSERT INTO tt_printqty VALUES(concat('Label Type: ',rLoop.label_type));
#	INSERT INTO tt_printqty VALUES(concat('Quantity: ',rLoop.quantity));
#
#	tDb := rLoop.database;
#    end loop;
#end; $$;
#
#SELECT * FROM tt_printqty;

##################### CREATE TEMP TABLE WITH GEN ATTR AND LE DIFFERENCES #########################
# compare gen attribute data to LE data
CHECK_GENATTR = do $$ declare tConnName text := 'lblcmd_checkgenattr'; tDbName text; tLEVersion text; rGattr record; begin DROP TABLE IF EXISTS tt_genattr; DROP TABLE IF EXISTS tt_genattr2; CREATE TEMP TABLE tt_genattr(attr_name text, attr_data text, status text); CREATE TEMP TABLE tt_genattr2(attr_name text, attr_data text, status text) ON COMMIT DROP; if dblink_get_connections() @> array[tConnName] then PERFORM dblink_disconnect(tConnName); end if; for tDbName in select datname from pg_database order by datname loop begin PERFORM dblink_connect_u(tConnName, 'dbname='|| tDbName ||' use=postgres password=postgres'); if exists(SELECT true FROM dblink(tConnName, 'SELECT gad.attr_name, ga.attr_data FROM gen_attr ga, gen_attr_def gad WHERE ga.gen_attr_def_key = gad.gen_attr_def_key AND gad.table_name = ''project'' AND gad.attr_name = ''postgres_context'' AND ga.attr_data = ''postgres-webservice''') AS t(attr_name text, attr_data text)) then PERFORM dblink_disconnect(tConnName); PERFORM dblink_connect_u(tConnName, 'dbname='|| tDbName ||' user=postgres password=postgres'); tLEVersion := 'non-hibernate'; else PERFORM dblink_disconnect(tConnName); PERFORM dblink_connect_u(tConnName, 'dbname='|| tDbName ||' user=labelengine password=postgres'); tLEVersion := 'hibernate'; end if; exception when others then if dblink_get_connections() @> array[tConnName] then PERFORM dblink_disconnect(tConnName); end if; continue; end; begin INSERT INTO tt_genattr VALUES('-----------------------', tDbName, '-----------------------'); INSERT INTO tt_genattr2 SELECT *, 'ERROR' FROM dblink(tConnName, 'SELECT gad.attr_name, ga.attr_data FROM gen_attr ga, gen_attr_def gad WHERE gad.table_name = ''project'' AND (gad.attr_name = ''postgres_context'' OR gad.attr_name LIKE ''postgres_token%'') AND ga.gen_attr_def_key = gad.gen_attr_def_key') AS t(attr_name text, attr_data text); if tLEVersion = 'hibernate' then UPDATE tt_genattr2 SET status = 'OK' WHERE attr_data = 'le-labels' OR attr_data = 'LabelEngine'; UPDATE tt_genattr2 SET status = 'OK' WHERE attr_name = 'postgres_token' AND attr_data = (SELECT * FROM dblink(tConnName, 'SELECT value FROM tokencreation tc INNER JOIN token_audit_system ta ON tc.user_id = ta.id WHERE ''postgres_TOKEN'' like ''%'' || upper(ta.name) || ''%''') AS t(value text)); UPDATE tt_genattr2 SET status = 'OK' WHERE attr_name = 'postgres_token_SFDC' AND attr_data = (SELECT * FROM dblink(tConnName, 'SELECT value FROM tokencreation tc INNER JOIN token_audit_system ta ON tc.user_id = ta.id WHERE ''postgres_TOKEN_SFDC'' like ''%'' || upper(ta.name) || ''%''') AS t(value text)); else UPDATE tt_genattr2 SET status = 'OK' WHERE attr_data = 'postgres-webservice'; UPDATE tt_genattr2 SET status = 'OK' WHERE attr_name = 'postgres_token' AND attr_data = (SELECT * FROM dblink(tConnName, 'SELECT value FROM token t INNER JOIN std_code s ON t.token_system_key = s.std_code_key WHERE ''postgres_TOKEN'' like ''%'' || upper(s.std_code_description) || ''%''') AS t(value text)); UPDATE tt_genattr2 SET status = 'OK' WHERE attr_name = 'postgres_token_SFDC' AND attr_data = (SELECT * FROM dblink(tConnName, 'SELECT value FROM token t INNER JOIN std_code s ON t.token_system_key = s.std_code_key WHERE ''postgres_TOKEN_SFDC'' like ''%'' || upper(s.std_code_description) || ''%''') AS t(value text)); end if; PERFORM dblink_disconnect(tConnName); INSERT INTO tt_genattr SELECT * FROM tt_genattr2 ORDER BY attr_name; DELETE FROM tt_genattr2; INSERT INTO tt_genattr VALUES('', '', ''); exception when others then if dblink_get_connections() @> array[tConnName] then PERFORM dblink_disconnect(tConnName); end if; DELETE FROM tt_genattr2; continue; end; end loop; end; $$

#do $$
#declare
#    tConnName text := 'lblcmd_checkgenattr';
#    tDbName text;
#    tLEVersion text;
#    rGattr record;
#
#begin
#    DROP TABLE IF EXISTS tt_genattr;
#    DROP TABLE IF EXISTS tt_genattr2;
#    CREATE TEMP TABLE tt_genattr(attr_name text, attr_data text, status text);
#    CREATE TEMP TABLE tt_genattr2(attr_name text, attr_data text, status text) ON COMMIT DROP;
#
#    --if the connection already exists, disconnect
#    if dblink_get_connections() @> array[tConnName] then
#	PERFORM dblink_disconnect(tConnName);
#    end if;
#
#    for tDbName in select datname from pg_database order by datname loop
#	--create a connection
#	begin
#	    PERFORM dblink_connect_u(tConnName, 'dbname='|| tDbName ||' use=postgres password=postgres');
#
#	    --checking if LE Non-Hibernate is being used, if not, connect on hibernate
#	    if exists(SELECT true FROM dblink(tConnName,
#				'SELECT gad.attr_name, ga.attr_data
#				   FROM gen_attr ga, gen_attr_def gad
#				  WHERE ga.gen_attr_def_key = gad.gen_attr_def_key AND
#					gad.table_name = ''project'' AND
#				        gad.attr_name = ''postgres_context'' AND
#				        ga.attr_data = ''postgres-webservice''')
#			  AS t(attr_name text, attr_data text)) then
#
#		PERFORM dblink_disconnect(tConnName);
#		PERFORM dblink_connect_u(tConnName, 'dbname='|| tDbName ||' user=postgres password=postgres');
#		tLEVersion := 'non-hibernate';
#	    else
#		PERFORM dblink_disconnect(tConnName);
#		PERFORM dblink_connect_u(tConnName, 'dbname='|| tDbName ||' user=labelengine password=postgres');
#		tLEVersion := 'hibernate';
#	    end if;
#	exception
#	    when others then
#		--if the connection already exists, disconnect
#		if dblink_get_connections() @> array[tConnName] then
#		    PERFORM dblink_disconnect(tConnName);
#		end if;
#		
#		continue;
#	end;
#
#	begin
#	    INSERT INTO tt_genattr VALUES('-----------------------', tDbName, '-----------------------');
#
#	    --get data through the connection
#	    INSERT INTO tt_genattr2
#		SELECT *, 'ERROR' FROM dblink(tConnName,
#			'SELECT gad.attr_name, ga.attr_data
#			 FROM gen_attr ga, gen_attr_def gad
#			 WHERE gad.table_name = ''project'' AND
#			      (gad.attr_name = ''postgres_context'' OR
#			       gad.attr_name LIKE ''postgres_token%'') AND
#			       ga.gen_attr_def_key = gad.gen_attr_def_key')
#		AS t(attr_name text, attr_data text);
#
#	    if tLEVersion = 'hibernate' then
#		UPDATE tt_genattr2 SET status = 'OK' WHERE attr_data = 'le-labels' OR attr_data = 'LabelEngine';
#
#		UPDATE tt_genattr2 SET status = 'OK'
#		 WHERE attr_name = 'postgres_token'
#		   AND attr_data = (SELECT * FROM dblink(tConnName,
#				   'SELECT value FROM tokencreation tc INNER JOIN token_audit_system ta ON tc.user_id = ta.id
#				     WHERE ''postgres_TOKEN'' like ''%'' || upper(ta.name) || ''%''') AS t(value text));
#				     
#		UPDATE tt_genattr2 SET status = 'OK'
#		 WHERE attr_name = 'postgres_token_SFDC'
#		   AND attr_data = (SELECT * FROM dblink(tConnName,
#				   'SELECT value FROM tokencreation tc INNER JOIN token_audit_system ta ON tc.user_id = ta.id
#				     WHERE ''postgres_TOKEN_SFDC'' like ''%'' || upper(ta.name) || ''%''') AS t(value text));
#	    else
#		UPDATE tt_genattr2 SET status = 'OK' WHERE attr_data = 'postgres-webservice';
#		
#		UPDATE tt_genattr2 SET status = 'OK'
#		 WHERE attr_name = 'postgres_token'
#		   AND attr_data = (SELECT * FROM dblink(tConnName,
#				   'SELECT value FROM token t INNER JOIN std_code s ON t.token_system_key = s.std_code_key
#				     WHERE ''postgres_TOKEN'' like ''%'' || upper(s.std_code_description) || ''%''') AS t(value text));
#
#		UPDATE tt_genattr2 SET status = 'OK'
#		 WHERE attr_name = 'postgres_token_SFDC'
#		   AND attr_data = (SELECT * FROM dblink(tConnName,
#				   'SELECT value FROM token t INNER JOIN std_code s ON t.token_system_key = s.std_code_key
#				     WHERE ''postgres_TOKEN_SFDC'' like ''%'' || upper(s.std_code_description) || ''%''') AS t(value text));
#	    end if;
#
#	    --if everything was ok, disconnect
#	    PERFORM dblink_disconnect(tConnName);
#
#	    INSERT INTO tt_genattr SELECT * FROM tt_genattr2 ORDER BY attr_name;
#
#	    --cleaning secondary table to avoid data conflicts
#	    DELETE FROM tt_genattr2;
#	    
#	    --add a blank line to improve the data view
#	    INSERT INTO tt_genattr VALUES('', '', '');
#
#	exception
#	    when others then
#		if dblink_get_connections() @> array[tConnName] then
#		    PERFORM dblink_disconnect(tConnName);
#		end if;
#
#		DELETE FROM tt_genattr2;
#		continue;
#	end;
#    end loop;
#end; $$

############################### CHECK GEN ATTRIBUTE TABLE DATA ###################################
# get a list of differences between gen attribute and LE configurations
COMPARE_GENATTR = SELECT attr_name, attr_data, status FROM tt_genattr

############################### LIST USED FUNCTIONS IN A PERIOD ###################################
# get a list of used Special Functions in a period from LE Non-Hibernate
GET_USED_SF = SELECT DISTINCT dbf.function_name, label.name label_name FROM db_function dbf LEFT JOIN element_block_details_04_db_function ebd4 ON ebd4.db_function_key = dbf.db_function_key LEFT JOIN element_block elb ON elb.element_block_key = ebd4.element_block_key AND block_type_key = ( SELECT std_code_key FROM std_code WHERE upper(std_code_description) = 'DB SCALAR FUNCTION') LEFT JOIN label_element le ON le.element_key = elb.element_key LEFT JOIN audit_print_batch apb ON apb.label_key = le.label_key LEFT JOIN label ON label.label_key = le.label_key WHERE apb.start_dt BETWEEN '_start_date' AND '_end_date' ORDER BY dbf.function_name

#SELECT DISTINCT dbf.function_name, label.name label_name FROM db_function dbf
#LEFT JOIN element_block_details_04_db_function ebd4 ON ebd4.db_function_key = dbf.db_function_key
#LEFT JOIN element_block elb ON elb.element_block_key = ebd4.element_block_key AND block_type_key = (
#	SELECT std_code_key FROM std_code WHERE upper(std_code_description) = 'DB SCALAR FUNCTION')
#LEFT JOIN label_element le ON le.element_key = elb.element_key
#LEFT JOIN audit_print_batch apb ON apb.label_key = le.label_key
#LEFT JOIN label ON label.label_key = le.label_key
#WHERE apb.start_dt BETWEEN '_start_date' AND '_end_date'
#ORDER BY dbf.function_name

############################### LIST LE LABELS THAT HAVE FUNCTIONS ###############################
# get a list of labels that depends of functions from LE Non-Hibernate
CHECK_LABELS = do $$ begin DROP TABLE IF EXISTS tt_checklabels; CREATE TEMP TABLE tt_checklabels(label_name text, function_name text, func_installed text, file_template text, file_installed text); INSERT INTO tt_checklabels(label_name, function_name, func_installed) SELECT DISTINCT l.name, f.function_name, 'NO' FROM db_function f INNER JOIN element_block_details_04_db_function dt ON f.db_function_key = dt.db_function_key INNER JOIN element_block eb ON dt.element_block_key = eb.element_block_key INNER JOIN label_element le ON eb.element_key = le.element_key INNER JOIN label l ON le.label_key = l.label_key; UPDATE tt_checklabels SET func_installed = 'YES' WHERE function_name in (SELECT proname FROM pg_proc); UPDATE tt_checklabels SET file_template = split_part(split_part(prosrc,'/graphics/labelengine/',2),'''',1), file_installed = 'NO' FROM pg_proc WHERE function_name = proname AND prosrc like '%/graphics/labelengine/%'; UPDATE tt_checklabels SET file_installed = 'YES' WHERE file_template in (SELECT replace(split_part(csyscall('ls /graphics/labelengine/' || file_template),'/',6),E'\n','') FROM tt_checklabels); end $$
GET_LABELS = SELECT * FROM tt_checklabels ORDER BY label_name

#do $$
#begin
#	DROP TABLE IF EXISTS tt_checklabels;
#	CREATE TEMP TABLE tt_checklabels(label_name text, function_name text, func_installed text, file_template text, file_installed text);
#
#	--getting list of label with functions
#	INSERT INTO tt_checklabels(label_name, function_name, func_installed)
#		SELECT DISTINCT l.name, f.function_name, 'NO' FROM db_function f
#		INNER JOIN element_block_details_04_db_function dt ON f.db_function_key = dt.db_function_key
#		INNER JOIN element_block eb ON dt.element_block_key = eb.element_block_key
#		INNER JOIN label_element le ON eb.element_key = le.element_key
#		INNER JOIN label l ON le.label_key = l.label_key;
#
#	--checking if the functions are installed on database
#	UPDATE tt_checklabels SET func_installed = 'YES'
#		WHERE function_name in (SELECT proname FROM pg_proc);
#
#	--checking if functions depends of file_template files
#	UPDATE tt_checklabels SET file_template = split_part(split_part(prosrc,'/graphics/labelengine/',2),'''',1), file_installed = 'NO'
#		FROM pg_proc WHERE function_name = proname AND prosrc like '%/graphics/labelengine/%';
#
#	--checking if file_template files are present on server folder
#	UPDATE tt_checklabels SET file_installed = 'YES'
#		WHERE file_template in (SELECT replace(split_part(csyscall('ls /graphics/labelengine/' || file_template),'/',6),E'\n','') FROM tt_checklabels);
#
#end $$;
#SELECT * FROM tt_checklabels ORDER BY label_name

############################### COMPARE LE FUNCTIONS WITH SVN PATH ###############################
# get a list of LE labels that depends of functions from LE Non-Hibernate and compare to SVN paths
COMPARE_SVN_PATH_LE = do $$ declare tProcName text; tBranch text; tTrunk text; begin DROP TABLE IF EXISTS tt_checkfunction; DROP TABLE IF EXISTS tt_svn_branch; DROP TABLE IF EXISTS tt_svn_trunk; CREATE TEMP TABLE tt_checkfunction(function_name text, branch_size text, trunk_size text); CREATE TEMP TABLE tt_svn_branch(file_desc text) ON COMMIT DROP; CREATE TEMP TABLE tt_svn_trunk(file_desc text) ON COMMIT DROP; INSERT INTO tt_svn_branch SELECT regexp_split_to_table(csyscall('svn list _branchpath -v --username _user --password "_pass" --no-auth-cache'), chr(10)); INSERT INTO tt_svn_trunk SELECT regexp_split_to_table(csyscall('svn list _trunkpath -v --username _user --password "_pass" --no-auth-cache'), chr(10)); if exists(SELECT true FROM tt_svn_branch WHERE lower(file_desc) like '%non-existent in that revision%') or exists(SELECT true FROM tt_svn_trunk WHERE lower(file_desc) like '%non-existent in that revision%') then INSERT INTO tt_checkfunction VALUES('SVN path(s) not found.'); return; end if; if exists(SELECT true FROM tt_svn_branch WHERE lower(file_desc) like '%authentication realm%') then INSERT INTO tt_checkfunction VALUES('Invalid username or password.'); return; end if; for tProcName in SELECT function_name FROM db_function GROUP BY function_name ORDER BY function_name loop SELECT split_part(trim(split_part(file_desc,'   ',2)),' ',1) FROM tt_svn_branch WHERE file_desc like '%' || tProcName || '.sql' INTO tBranch; SELECT split_part(trim(split_part(file_desc,'   ',2)),' ',1) FROM tt_svn_trunk WHERE file_desc like '%' || tProcName || '.sql' INTO tTrunk; tBranch := coalesce(tBranch,'NOT FOUND'); tTrunk := coalesce(tTrunk,'NOT FOUND'); if (tBranch <> tTrunk) OR (tBranch = 'NOT FOUND' AND tTrunk = 'NOT FOUND') then INSERT INTO tt_checkfunction VALUES(tProcName, tBranch, tTrunk); else INSERT INTO tt_checkfunction VALUES(tProcName, 'Same file size.', ''); end if; end loop; end; $$

#do $$
#declare
#    tProcName text;
#    tBranch text;
#    tTrunk text;
#
#begin
#    DROP TABLE IF EXISTS tt_checkfunction;
#    DROP TABLE IF EXISTS tt_svn_branch;
#    DROP TABLE IF EXISTS tt_svn_trunk;
#    CREATE TEMP TABLE tt_checkfunction(function_name text, branch_size text, trunk_size text);
#    CREATE TEMP TABLE tt_svn_branch(file_desc text) ON COMMIT DROP;
#    CREATE TEMP TABLE tt_svn_trunk(file_desc text) ON COMMIT DROP;
#
#	--inserting paths file list into temp tables 
#    INSERT INTO tt_svn_branch SELECT regexp_split_to_table(csyscall('svn list _branchpath -v --username _user --password "_pass" --no-auth-cache'), chr(10));
#    INSERT INTO tt_svn_trunk SELECT regexp_split_to_table(csyscall('svn list _trunkpath -v --username _user --password "_pass" --no-auth-cache'), chr(10));
#
#	--checking if the paths exists
#    if exists(SELECT true FROM tt_svn_branch WHERE lower(file_desc) like '%non-existent in that revision%')
#		or exists(SELECT true FROM tt_svn_trunk WHERE lower(file_desc) like '%non-existent in that revision%') then
#
#		INSERT INTO tt_checkfunction VALUES('SVN path(s) not found.');
#		return;
#    end if;
#
#	--checking if authentication is ok
#    if exists(SELECT true FROM tt_svn_branch WHERE lower(file_desc) like '%authentication realm%') then
#		INSERT INTO tt_checkfunction VALUES('Invalid username or password.');
#		return;
#    end if;
#
#    for tProcName in SELECT function_name FROM db_function GROUP BY function_name ORDER BY function_name
#    loop
#		--get the files size
#		SELECT split_part(trim(split_part(file_desc,'     ',2)),' ',1) FROM tt_svn_branch WHERE file_desc like '%' || tProcName || '.sql' INTO tBranch;
#		SELECT split_part(trim(split_part(file_desc,'     ',2)),' ',1) FROM tt_svn_trunk WHERE file_desc like '%' || tProcName || '.sql' INTO tTrunk;
#
#		-- if null file was not found
#		tBranch := coalesce(tBranch,'NOT FOUND');
#		tTrunk  := coalesce(tTrunk,'NOT FOUND');
#
#		--checking if files exists or are the same
#		if (tBranch <> tTrunk) OR (tBranch = 'NOT FOUND' AND tTrunk = 'NOT FOUND') then
#			INSERT INTO tt_checkfunction VALUES(tProcName, tBranch, tTrunk);
#		else
#			INSERT INTO tt_checkfunction VALUES(tProcName, 'Same file size.', '');
#		end if;
#    end loop;
#end; $$
